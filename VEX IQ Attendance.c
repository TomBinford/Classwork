#pragma config(Sensor, port1,  rightSonar,     sensorVexIQ_Distance)
#pragma config(Sensor, port2,  color1,         sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port4,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port7,  leftSonar,      sensorVexIQ_Distance)
#pragma config(Sensor, port9,  color2,         sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor6,          leftMotor,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         rightMotor,    tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool attending[3][2];

int studentsPresent = 0;

bool atStart = true;

bool onBlack = false;

float driftRate = 0;

float gyroValue = 0;

enum State
{
	Scanning,
	DrivingForward,
	TurningAround,
	NudgingLeft,
	NudgingRight
};

struct Side
{
	tMotor m;
};

struct Chassis
{
	Side leftSide;
	Side rightSide;
};

struct Robot
{
	Chassis chassis;
	State state;
};

Robot robot;

void init()
{
	robot.chassis.leftSide = leftMotor;
	robot.chassis.rightSide = rightMotor;
	robot.state = DrivingForward;
	setColorMode(color1, colorTypeGrayscale_Reflected);
	setColorMode(color2, colorTypeGrayscale_Reflected);
	time1[T1] = 0;
}


void gyroCorrect()
{
	long currentTime = time1[T1];
	if (currentTime < 5)
	{
		return;
	}
	time1[T1] = 0;
	float currentRate = getGyroRateFloat(gyro) - driftRate;
	gyroValue += currentRate/(1000 / (float)currentTime);
}

void gyroCalibration()
{
	time1[T1] = 0;
	float sum = 0;
	int count = 0;
	while(time1[T1] < 5000)
	{
		sum += getGyroRateFloat(gyro);
		count++;
		delay(5);
	}

	driftRate = sum / count;

	time1[T1] = 0;
}

bool isAtNextLine()
{
	if(getColorValue(color1) < 50 || getColorValue(color2) < 50)
	{
		onBlack = true;
		return false;
		}
	if(getColorValue(color1) > 50 || getColorValue(color2) > 50)
	{
		if(onBlack)
		{
			return true;
		}
	}
		return false;
}

void setChassisPowers(int leftPower, int rightPower)
{
	motor[robot.chassis.leftSide] = leftPower;
	motor[robot.chassis.rightSide] = rightPower;
}

task main()
{
	time1[T1] = 0;
	init();
	gyroCalibration();
	int row = -1;
	while(true)
	{
		gyroCorrect();
		switch(robot.state)
		{
		case Scanning:
			if(row <= 2)
			{
				if(SensorValue[rightSonar] < 200)
				{
					attending[row][1] = true;
					studentsPresent++;
				}
				else
				{
					attending[row][1] = false;
				}
				if(SensorValue[leftSonar] < 200)
				{
					attending[row][0] = true;
					studentsPresent++;
				}
				else
				{
					attending[row][0] = false;
				}
				robot.state = DrivingForward;
			}
			else
			{
				robot.state = TurningAround;
			}
			break;
		case DrivingForward:
			if(atStart)
			{
				if(isAtNextLine())
				{
					setChassisPowers(0, 0);
					atStart = false;
					onBlack = false;
				}
				else
				{
					if((int)gyroValue%180 < -2)
					{
						setChassisPowers(50, 60);
					}
					else if((int)gyroValue%180 > 2)
					{
						setChassisPowers(60, 50);
					}
					else
					{
						setChassisPowers(50, 50);
					}
				}
			}
			else if(row < 4)
			{
				if(isAtNextLine())
				{
					setChassisPowers(0, 0);
					robot.state = Scanning;
					row++;
					onBlack = false;
				}
				else
				{
					if((int)gyroValue%180 < -2)
					{
						setChassisPowers(50, 60);
					}
					else if((int)gyroValue%180 > 2)
					{
						setChassisPowers(60, 50);
					}
					else
					{
						setChassisPowers(50, 50);
					}
				}
			}
			else if(row >= 5)
			{
				if(isAtNextLine())
				{
					setChassisPowers(0, 0);
					row++;
					onBlack = false;
				}
				else
				{
					if((int)gyroValue%180 < -2)
					{
						setChassisPowers(50, 60);
					}
					else if((int)gyroValue%180 > 2)
					{
						setChassisPowers(60, 50);
					}
					else
					{
						setChassisPowers(50, 50);
					}
				}
			}
			break;
		case NudgingLeft:
			break;
		case NudgingRight:
			break;
		case TurningAround:
			if(gyroValue < 180)
			{
				setChassisPowers(-25, 25);
			}
			else
			{
				row++;
				setChassisPowers(0, 0);
				robot.state = DrivingForward;
			}
			break;
		}
		if(attending[0][0] && !attending[0][1])
		{
			displayTextLine(1, "R1 Left");
		}
		else if(attending[0][1] && !attending[0][0])
		{
			displayTextLine(1, "R1 Right");
		}
		else if(attending[0][0] && attending[0][1])
		{
			displayTextLine(1, "R1 Both");
		}
		else
		{
			displayTextLine(1, "R1 None");
		}
		if(attending[1][0] && !attending[1][1])
		{
			displayTextLine(2, "R2 Left");
		}
		else if(attending[1][1] && !attending[1][0])
		{
			displayTextLine(2, "R2 Right");
		}
		else if(attending[1][0] && attending[1][1])
		{
			displayTextLine(2, "R2 Both");
		}
		else
		{
			displayTextLine(2, "R2 None");
		}
		if(attending[2][0] && !attending[2][1])
		{
			displayTextLine(3, "R3 Left");
		}
		else if(attending[2][1] && !attending[2][0])
		{
			displayTextLine(3, "R3 Right");
		}
		else if(attending[2][0] && attending[2][1])
		{
			displayTextLine(3, "R3 Both");
		}
		else
		{
			displayTextLine(3, "R3 None");
		}
		//displayTextLine(5, "Present: %d", studentsPresent);
		displayTextLine(5, "Row: %d", row);
	}
}
